{"trustedAgents":[],"knownLinkLanguages":[],"directMessageLanguage":"","agentLanguage":"","perspectiveLanguage":"","neighbourhoodLanguage":"","languageLanguageBundle":"// deno-fmt-ignore-file\n// deno-lint-ignore-file\n// This code was bundled using `deno bundle` and it's not recommended to edit it manually\n\nconst osType = (()=>{\n    const { Deno: Deno1  } = globalThis;\n    if (typeof Deno1?.build?.os === \"string\") {\n        return Deno1.build.os;\n    }\n    const { navigator  } = globalThis;\n    if (navigator?.appVersion?.includes?.(\"Win\")) {\n        return \"windows\";\n    }\n    return \"linux\";\n})();\nconst isWindows = osType === \"windows\";\nconst CHAR_FORWARD_SLASH = 47;\nfunction assertPath(path) {\n    if (typeof path !== \"string\") {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\nfunction isPosixPathSeparator(code) {\n    return code === 47;\n}\nfunction isPathSeparator(code) {\n    return isPosixPathSeparator(code) || code === 92;\n}\nfunction isWindowsDeviceRoot(code) {\n    return code >= 97 && code <= 122 || code >= 65 && code <= 90;\n}\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = \"\";\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code;\n    for(let i = 0, len = path.length; i <= len; ++i){\n        if (i < len) code = path.charCodeAt(i);\n        else if (isPathSeparator(code)) break;\n        else code = CHAR_FORWARD_SLASH;\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = \"\";\n                            lastSegmentLength = 0;\n                        } else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = \"\";\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) res += `${separator}..`;\n                    else res = \"..\";\n                    lastSegmentLength = 2;\n                }\n            } else {\n                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n                else res = path.slice(lastSlash + 1, i);\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        } else if (code === 46 && dots !== -1) {\n            ++dots;\n        } else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base || (pathObject.name || \"\") + (pathObject.ext || \"\");\n    if (!dir) return base;\n    if (base === sep) return dir;\n    if (dir === pathObject.root) return dir + base;\n    return dir + sep + base;\n}\nconst WHITESPACE_ENCODINGS = {\n    \"\\u0009\": \"%09\",\n    \"\\u000A\": \"%0A\",\n    \"\\u000B\": \"%0B\",\n    \"\\u000C\": \"%0C\",\n    \"\\u000D\": \"%0D\",\n    \"\\u0020\": \"%20\"\n};\nfunction encodeWhitespace(string) {\n    return string.replaceAll(/[\\s]/g, (c)=>{\n        return WHITESPACE_ENCODINGS[c] ?? c;\n    });\n}\nfunction lastPathSegment(path, isSep, start = 0) {\n    let matchedNonSeparator = false;\n    let end = path.length;\n    for(let i = path.length - 1; i >= start; --i){\n        if (isSep(path.charCodeAt(i))) {\n            if (matchedNonSeparator) {\n                start = i + 1;\n                break;\n            }\n        } else if (!matchedNonSeparator) {\n            matchedNonSeparator = true;\n            end = i + 1;\n        }\n    }\n    return path.slice(start, end);\n}\nfunction stripTrailingSeparators(segment, isSep) {\n    if (segment.length <= 1) {\n        return segment;\n    }\n    let end = segment.length;\n    for(let i = segment.length - 1; i > 0; i--){\n        if (isSep(segment.charCodeAt(i))) {\n            end = i;\n        } else {\n            break;\n        }\n    }\n    return segment.slice(0, end);\n}\nfunction stripSuffix(name, suffix) {\n    if (suffix.length >= name.length) {\n        return name;\n    }\n    const lenDiff = name.length - suffix.length;\n    for(let i = suffix.length - 1; i >= 0; --i){\n        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {\n            return name;\n        }\n    }\n    return name.slice(0, -suffix.length);\n}\nclass DenoStdInternalError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"DenoStdInternalError\";\n    }\n}\nfunction assert(expr, msg = \"\") {\n    if (!expr) {\n        throw new DenoStdInternalError(msg);\n    }\n}\nconst sep = \"\\\\\";\nconst delimiter = \";\";\nfunction resolve(...pathSegments) {\n    let resolvedDevice = \"\";\n    let resolvedTail = \"\";\n    let resolvedAbsolute = false;\n    for(let i = pathSegments.length - 1; i >= -1; i--){\n        let path;\n        const { Deno: Deno1  } = globalThis;\n        if (i >= 0) {\n            path = pathSegments[i];\n        } else if (!resolvedDevice) {\n            if (typeof Deno1?.cwd !== \"function\") {\n                throw new TypeError(\"Resolved a drive-letter-less path without a CWD.\");\n            }\n            path = Deno1.cwd();\n        } else {\n            if (typeof Deno1?.env?.get !== \"function\" || typeof Deno1?.cwd !== \"function\") {\n                throw new TypeError(\"Resolved a relative path without a CWD.\");\n            }\n            path = Deno1.cwd();\n            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\\\`) {\n                path = `${resolvedDevice}\\\\`;\n            }\n        }\n        assertPath(path);\n        const len = path.length;\n        if (len === 0) continue;\n        let rootEnd = 0;\n        let device = \"\";\n        let isAbsolute = false;\n        const code = path.charCodeAt(0);\n        if (len > 1) {\n            if (isPathSeparator(code)) {\n                isAbsolute = true;\n                if (isPathSeparator(path.charCodeAt(1))) {\n                    let j = 2;\n                    let last = j;\n                    for(; j < len; ++j){\n                        if (isPathSeparator(path.charCodeAt(j))) break;\n                    }\n                    if (j < len && j !== last) {\n                        const firstPart = path.slice(last, j);\n                        last = j;\n                        for(; j < len; ++j){\n                            if (!isPathSeparator(path.charCodeAt(j))) break;\n                        }\n                        if (j < len && j !== last) {\n                            last = j;\n                            for(; j < len; ++j){\n                                if (isPathSeparator(path.charCodeAt(j))) break;\n                            }\n                            if (j === len) {\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last)}`;\n                                rootEnd = j;\n                            } else if (j !== last) {\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                                rootEnd = j;\n                            }\n                        }\n                    }\n                } else {\n                    rootEnd = 1;\n                }\n            } else if (isWindowsDeviceRoot(code)) {\n                if (path.charCodeAt(1) === 58) {\n                    device = path.slice(0, 2);\n                    rootEnd = 2;\n                    if (len > 2) {\n                        if (isPathSeparator(path.charCodeAt(2))) {\n                            isAbsolute = true;\n                            rootEnd = 3;\n                        }\n                    }\n                }\n            }\n        } else if (isPathSeparator(code)) {\n            rootEnd = 1;\n            isAbsolute = true;\n        }\n        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n            continue;\n        }\n        if (resolvedDevice.length === 0 && device.length > 0) {\n            resolvedDevice = device;\n        }\n        if (!resolvedAbsolute) {\n            resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n            resolvedAbsolute = isAbsolute;\n        }\n        if (resolvedAbsolute && resolvedDevice.length > 0) break;\n    }\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, \"\\\\\", isPathSeparator);\n    return resolvedDevice + (resolvedAbsolute ? \"\\\\\" : \"\") + resolvedTail || \".\";\n}\nfunction normalize(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0) return \".\";\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n    if (len > 1) {\n        if (isPathSeparator(code)) {\n            isAbsolute = true;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                let j = 2;\n                let last = j;\n                for(; j < len; ++j){\n                    if (isPathSeparator(path.charCodeAt(j))) break;\n                }\n                if (j < len && j !== last) {\n                    const firstPart = path.slice(last, j);\n                    last = j;\n                    for(; j < len; ++j){\n                        if (!isPathSeparator(path.charCodeAt(j))) break;\n                    }\n                    if (j < len && j !== last) {\n                        last = j;\n                        for(; j < len; ++j){\n                            if (isPathSeparator(path.charCodeAt(j))) break;\n                        }\n                        if (j === len) {\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n                        } else if (j !== last) {\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                            rootEnd = j;\n                        }\n                    }\n                }\n            } else {\n                rootEnd = 1;\n            }\n        } else if (isWindowsDeviceRoot(code)) {\n            if (path.charCodeAt(1) === 58) {\n                device = path.slice(0, 2);\n                rootEnd = 2;\n                if (len > 2) {\n                    if (isPathSeparator(path.charCodeAt(2))) {\n                        isAbsolute = true;\n                        rootEnd = 3;\n                    }\n                }\n            }\n        }\n    } else if (isPathSeparator(code)) {\n        return \"\\\\\";\n    }\n    let tail;\n    if (rootEnd < len) {\n        tail = normalizeString(path.slice(rootEnd), !isAbsolute, \"\\\\\", isPathSeparator);\n    } else {\n        tail = \"\";\n    }\n    if (tail.length === 0 && !isAbsolute) tail = \".\";\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n        tail += \"\\\\\";\n    }\n    if (device === undefined) {\n        if (isAbsolute) {\n            if (tail.length > 0) return `\\\\${tail}`;\n            else return \"\\\\\";\n        } else if (tail.length > 0) {\n            return tail;\n        } else {\n            return \"\";\n        }\n    } else if (isAbsolute) {\n        if (tail.length > 0) return `${device}\\\\${tail}`;\n        else return `${device}\\\\`;\n    } else if (tail.length > 0) {\n        return device + tail;\n    } else {\n        return device;\n    }\n}\nfunction isAbsolute(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0) return false;\n    const code = path.charCodeAt(0);\n    if (isPathSeparator(code)) {\n        return true;\n    } else if (isWindowsDeviceRoot(code)) {\n        if (len > 2 && path.charCodeAt(1) === 58) {\n            if (isPathSeparator(path.charCodeAt(2))) return true;\n        }\n    }\n    return false;\n}\nfunction join(...paths) {\n    const pathsCount = paths.length;\n    if (pathsCount === 0) return \".\";\n    let joined;\n    let firstPart = null;\n    for(let i = 0; i < pathsCount; ++i){\n        const path = paths[i];\n        assertPath(path);\n        if (path.length > 0) {\n            if (joined === undefined) joined = firstPart = path;\n            else joined += `\\\\${path}`;\n        }\n    }\n    if (joined === undefined) return \".\";\n    let needsReplace = true;\n    let slashCount = 0;\n    assert(firstPart != null);\n    if (isPathSeparator(firstPart.charCodeAt(0))) {\n        ++slashCount;\n        const firstLen = firstPart.length;\n        if (firstLen > 1) {\n            if (isPathSeparator(firstPart.charCodeAt(1))) {\n                ++slashCount;\n                if (firstLen > 2) {\n                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;\n                    else {\n                        needsReplace = false;\n                    }\n                }\n            }\n        }\n    }\n    if (needsReplace) {\n        for(; slashCount < joined.length; ++slashCount){\n            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;\n        }\n        if (slashCount >= 2) joined = `\\\\${joined.slice(slashCount)}`;\n    }\n    return normalize(joined);\n}\nfunction relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n    if (from === to) return \"\";\n    const fromOrig = resolve(from);\n    const toOrig = resolve(to);\n    if (fromOrig === toOrig) return \"\";\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n    if (from === to) return \"\";\n    let fromStart = 0;\n    let fromEnd = from.length;\n    for(; fromStart < fromEnd; ++fromStart){\n        if (from.charCodeAt(fromStart) !== 92) break;\n    }\n    for(; fromEnd - 1 > fromStart; --fromEnd){\n        if (from.charCodeAt(fromEnd - 1) !== 92) break;\n    }\n    const fromLen = fromEnd - fromStart;\n    let toStart = 0;\n    let toEnd = to.length;\n    for(; toStart < toEnd; ++toStart){\n        if (to.charCodeAt(toStart) !== 92) break;\n    }\n    for(; toEnd - 1 > toStart; --toEnd){\n        if (to.charCodeAt(toEnd - 1) !== 92) break;\n    }\n    const toLen = toEnd - toStart;\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for(; i <= length; ++i){\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === 92) {\n                    return toOrig.slice(toStart + i + 1);\n                } else if (i === 2) {\n                    return toOrig.slice(toStart + i);\n                }\n            }\n            if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === 92) {\n                    lastCommonSep = i;\n                } else if (i === 2) {\n                    lastCommonSep = 3;\n                }\n            }\n            break;\n        }\n        const fromCode = from.charCodeAt(fromStart + i);\n        const toCode = to.charCodeAt(toStart + i);\n        if (fromCode !== toCode) break;\n        else if (fromCode === 92) lastCommonSep = i;\n    }\n    if (i !== length && lastCommonSep === -1) {\n        return toOrig;\n    }\n    let out = \"\";\n    if (lastCommonSep === -1) lastCommonSep = 0;\n    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){\n        if (i === fromEnd || from.charCodeAt(i) === 92) {\n            if (out.length === 0) out += \"..\";\n            else out += \"\\\\..\";\n        }\n    }\n    if (out.length > 0) {\n        return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n    } else {\n        toStart += lastCommonSep;\n        if (toOrig.charCodeAt(toStart) === 92) ++toStart;\n        return toOrig.slice(toStart, toEnd);\n    }\n}\nfunction toNamespacedPath(path) {\n    if (typeof path !== \"string\") return path;\n    if (path.length === 0) return \"\";\n    const resolvedPath = resolve(path);\n    if (resolvedPath.length >= 3) {\n        if (resolvedPath.charCodeAt(0) === 92) {\n            if (resolvedPath.charCodeAt(1) === 92) {\n                const code = resolvedPath.charCodeAt(2);\n                if (code !== 63 && code !== 46) {\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n                }\n            }\n        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {\n                return `\\\\\\\\?\\\\${resolvedPath}`;\n            }\n        }\n    }\n    return path;\n}\nfunction dirname(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0) return \".\";\n    let rootEnd = -1;\n    let end = -1;\n    let matchedSlash = true;\n    let offset = 0;\n    const code = path.charCodeAt(0);\n    if (len > 1) {\n        if (isPathSeparator(code)) {\n            rootEnd = offset = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                let j = 2;\n                let last = j;\n                for(; j < len; ++j){\n                    if (isPathSeparator(path.charCodeAt(j))) break;\n                }\n                if (j < len && j !== last) {\n                    last = j;\n                    for(; j < len; ++j){\n                        if (!isPathSeparator(path.charCodeAt(j))) break;\n                    }\n                    if (j < len && j !== last) {\n                        last = j;\n                        for(; j < len; ++j){\n                            if (isPathSeparator(path.charCodeAt(j))) break;\n                        }\n                        if (j === len) {\n                            return path;\n                        }\n                        if (j !== last) {\n                            rootEnd = offset = j + 1;\n                        }\n                    }\n                }\n            }\n        } else if (isWindowsDeviceRoot(code)) {\n            if (path.charCodeAt(1) === 58) {\n                rootEnd = offset = 2;\n                if (len > 2) {\n                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;\n                }\n            }\n        }\n    } else if (isPathSeparator(code)) {\n        return path;\n    }\n    for(let i = len - 1; i >= offset; --i){\n        if (isPathSeparator(path.charCodeAt(i))) {\n            if (!matchedSlash) {\n                end = i;\n                break;\n            }\n        } else {\n            matchedSlash = false;\n        }\n    }\n    if (end === -1) {\n        if (rootEnd === -1) return \".\";\n        else end = rootEnd;\n    }\n    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\n}\nfunction basename(path, suffix = \"\") {\n    assertPath(path);\n    if (path.length === 0) return path;\n    if (typeof suffix !== \"string\") {\n        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);\n    }\n    let start = 0;\n    if (path.length >= 2) {\n        const drive = path.charCodeAt(0);\n        if (isWindowsDeviceRoot(drive)) {\n            if (path.charCodeAt(1) === 58) start = 2;\n        }\n    }\n    const lastSegment = lastPathSegment(path, isPathSeparator, start);\n    const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);\n    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\nfunction extname(path) {\n    assertPath(path);\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {\n        start = startPart = 2;\n    }\n    for(let i = path.length - 1; i >= start; --i){\n        const code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n            if (!matchedSlash) {\n                startPart = i + 1;\n                break;\n            }\n            continue;\n        }\n        if (end === -1) {\n            matchedSlash = false;\n            end = i + 1;\n        }\n        if (code === 46) {\n            if (startDot === -1) startDot = i;\n            else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n            preDotState = -1;\n        }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        return \"\";\n    }\n    return path.slice(startDot, end);\n}\nfunction format(pathObject) {\n    if (pathObject === null || typeof pathObject !== \"object\") {\n        throw new TypeError(`The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`);\n    }\n    return _format(\"\\\\\", pathObject);\n}\nfunction parse(path) {\n    assertPath(path);\n    const ret = {\n        root: \"\",\n        dir: \"\",\n        base: \"\",\n        ext: \"\",\n        name: \"\"\n    };\n    const len = path.length;\n    if (len === 0) return ret;\n    let rootEnd = 0;\n    let code = path.charCodeAt(0);\n    if (len > 1) {\n        if (isPathSeparator(code)) {\n            rootEnd = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                let j = 2;\n                let last = j;\n                for(; j < len; ++j){\n                    if (isPathSeparator(path.charCodeAt(j))) break;\n                }\n                if (j < len && j !== last) {\n                    last = j;\n                    for(; j < len; ++j){\n                        if (!isPathSeparator(path.charCodeAt(j))) break;\n                    }\n                    if (j < len && j !== last) {\n                        last = j;\n                        for(; j < len; ++j){\n                            if (isPathSeparator(path.charCodeAt(j))) break;\n                        }\n                        if (j === len) {\n                            rootEnd = j;\n                        } else if (j !== last) {\n                            rootEnd = j + 1;\n                        }\n                    }\n                }\n            }\n        } else if (isWindowsDeviceRoot(code)) {\n            if (path.charCodeAt(1) === 58) {\n                rootEnd = 2;\n                if (len > 2) {\n                    if (isPathSeparator(path.charCodeAt(2))) {\n                        if (len === 3) {\n                            ret.root = ret.dir = path;\n                            ret.base = \"\\\\\";\n                            return ret;\n                        }\n                        rootEnd = 3;\n                    }\n                } else {\n                    ret.root = ret.dir = path;\n                    return ret;\n                }\n            }\n        }\n    } else if (isPathSeparator(code)) {\n        ret.root = ret.dir = path;\n        ret.base = \"\\\\\";\n        return ret;\n    }\n    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for(; i >= rootEnd; --i){\n        code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n            if (!matchedSlash) {\n                startPart = i + 1;\n                break;\n            }\n            continue;\n        }\n        if (end === -1) {\n            matchedSlash = false;\n            end = i + 1;\n        }\n        if (code === 46) {\n            if (startDot === -1) startDot = i;\n            else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n            preDotState = -1;\n        }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        if (end !== -1) {\n            ret.base = ret.name = path.slice(startPart, end);\n        }\n    } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n        ret.ext = path.slice(startDot, end);\n    }\n    ret.base = ret.base || \"\\\\\";\n    if (startPart > 0 && startPart !== rootEnd) {\n        ret.dir = path.slice(0, startPart - 1);\n    } else ret.dir = ret.root;\n    return ret;\n}\nfunction fromFileUrl(url) {\n    url = url instanceof URL ? url : new URL(url);\n    if (url.protocol != \"file:\") {\n        throw new TypeError(\"Must be a file URL.\");\n    }\n    let path = decodeURIComponent(url.pathname.replace(/\\//g, \"\\\\\").replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\")).replace(/^\\\\*([A-Za-z]:)(\\\\|$)/, \"$1\\\\\");\n    if (url.hostname != \"\") {\n        path = `\\\\\\\\${url.hostname}${path}`;\n    }\n    return path;\n}\nfunction toFileUrl(path) {\n    if (!isAbsolute(path)) {\n        throw new TypeError(\"Must be an absolute path.\");\n    }\n    const [, hostname, pathname] = path.match(/^(?:[/\\\\]{2}([^/\\\\]+)(?=[/\\\\](?:[^/\\\\]|$)))?(.*)/);\n    const url = new URL(\"file:///\");\n    url.pathname = encodeWhitespace(pathname.replace(/%/g, \"%25\"));\n    if (hostname != null && hostname != \"localhost\") {\n        url.hostname = hostname;\n        if (!url.hostname) {\n            throw new TypeError(\"Invalid hostname.\");\n        }\n    }\n    return url;\n}\nconst mod = {\n    sep: sep,\n    delimiter: delimiter,\n    resolve: resolve,\n    normalize: normalize,\n    isAbsolute: isAbsolute,\n    join: join,\n    relative: relative,\n    toNamespacedPath: toNamespacedPath,\n    dirname: dirname,\n    basename: basename,\n    extname: extname,\n    format: format,\n    parse: parse,\n    fromFileUrl: fromFileUrl,\n    toFileUrl: toFileUrl\n};\nconst sep1 = \"/\";\nconst delimiter1 = \":\";\nfunction resolve1(...pathSegments) {\n    let resolvedPath = \"\";\n    let resolvedAbsolute = false;\n    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n        let path;\n        if (i >= 0) path = pathSegments[i];\n        else {\n            const { Deno: Deno1  } = globalThis;\n            if (typeof Deno1?.cwd !== \"function\") {\n                throw new TypeError(\"Resolved a relative path without a CWD.\");\n            }\n            path = Deno1.cwd();\n        }\n        assertPath(path);\n        if (path.length === 0) {\n            continue;\n        }\n        resolvedPath = `${path}/${resolvedPath}`;\n        resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n    }\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, \"/\", isPosixPathSeparator);\n    if (resolvedAbsolute) {\n        if (resolvedPath.length > 0) return `/${resolvedPath}`;\n        else return \"/\";\n    } else if (resolvedPath.length > 0) return resolvedPath;\n    else return \".\";\n}\nfunction normalize1(path) {\n    assertPath(path);\n    if (path.length === 0) return \".\";\n    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n    const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));\n    path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n    if (path.length === 0 && !isAbsolute) path = \".\";\n    if (path.length > 0 && trailingSeparator) path += \"/\";\n    if (isAbsolute) return `/${path}`;\n    return path;\n}\nfunction isAbsolute1(path) {\n    assertPath(path);\n    return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));\n}\nfunction join1(...paths) {\n    if (paths.length === 0) return \".\";\n    let joined;\n    for(let i = 0, len = paths.length; i < len; ++i){\n        const path = paths[i];\n        assertPath(path);\n        if (path.length > 0) {\n            if (!joined) joined = path;\n            else joined += `/${path}`;\n        }\n    }\n    if (!joined) return \".\";\n    return normalize1(joined);\n}\nfunction relative1(from, to) {\n    assertPath(from);\n    assertPath(to);\n    if (from === to) return \"\";\n    from = resolve1(from);\n    to = resolve1(to);\n    if (from === to) return \"\";\n    let fromStart = 1;\n    const fromEnd = from.length;\n    for(; fromStart < fromEnd; ++fromStart){\n        if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;\n    }\n    const fromLen = fromEnd - fromStart;\n    let toStart = 1;\n    const toEnd = to.length;\n    for(; toStart < toEnd; ++toStart){\n        if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;\n    }\n    const toLen = toEnd - toStart;\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for(; i <= length; ++i){\n        if (i === length) {\n            if (toLen > length) {\n                if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {\n                    return to.slice(toStart + i + 1);\n                } else if (i === 0) {\n                    return to.slice(toStart + i);\n                }\n            } else if (fromLen > length) {\n                if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {\n                    lastCommonSep = i;\n                } else if (i === 0) {\n                    lastCommonSep = 0;\n                }\n            }\n            break;\n        }\n        const fromCode = from.charCodeAt(fromStart + i);\n        const toCode = to.charCodeAt(toStart + i);\n        if (fromCode !== toCode) break;\n        else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;\n    }\n    let out = \"\";\n    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){\n        if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {\n            if (out.length === 0) out += \"..\";\n            else out += \"/..\";\n        }\n    }\n    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\n    else {\n        toStart += lastCommonSep;\n        if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;\n        return to.slice(toStart);\n    }\n}\nfunction toNamespacedPath1(path) {\n    return path;\n}\nfunction dirname1(path) {\n    if (path.length === 0) return \".\";\n    let end = -1;\n    let matchedNonSeparator = false;\n    for(let i = path.length - 1; i >= 1; --i){\n        if (isPosixPathSeparator(path.charCodeAt(i))) {\n            if (matchedNonSeparator) {\n                end = i;\n                break;\n            }\n        } else {\n            matchedNonSeparator = true;\n        }\n    }\n    if (end === -1) {\n        return isPosixPathSeparator(path.charCodeAt(0)) ? \"/\" : \".\";\n    }\n    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\n}\nfunction basename1(path, suffix = \"\") {\n    assertPath(path);\n    if (path.length === 0) return path;\n    if (typeof suffix !== \"string\") {\n        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);\n    }\n    const lastSegment = lastPathSegment(path, isPosixPathSeparator);\n    const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);\n    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\nfunction extname1(path) {\n    assertPath(path);\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for(let i = path.length - 1; i >= 0; --i){\n        const code = path.charCodeAt(i);\n        if (isPosixPathSeparator(code)) {\n            if (!matchedSlash) {\n                startPart = i + 1;\n                break;\n            }\n            continue;\n        }\n        if (end === -1) {\n            matchedSlash = false;\n            end = i + 1;\n        }\n        if (code === 46) {\n            if (startDot === -1) startDot = i;\n            else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n            preDotState = -1;\n        }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        return \"\";\n    }\n    return path.slice(startDot, end);\n}\nfunction format1(pathObject) {\n    if (pathObject === null || typeof pathObject !== \"object\") {\n        throw new TypeError(`The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`);\n    }\n    return _format(\"/\", pathObject);\n}\nfunction parse1(path) {\n    assertPath(path);\n    const ret = {\n        root: \"\",\n        dir: \"\",\n        base: \"\",\n        ext: \"\",\n        name: \"\"\n    };\n    if (path.length === 0) return ret;\n    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n    let start;\n    if (isAbsolute) {\n        ret.root = \"/\";\n        start = 1;\n    } else {\n        start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for(; i >= start; --i){\n        const code = path.charCodeAt(i);\n        if (isPosixPathSeparator(code)) {\n            if (!matchedSlash) {\n                startPart = i + 1;\n                break;\n            }\n            continue;\n        }\n        if (end === -1) {\n            matchedSlash = false;\n            end = i + 1;\n        }\n        if (code === 46) {\n            if (startDot === -1) startDot = i;\n            else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n            preDotState = -1;\n        }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        if (end !== -1) {\n            if (startPart === 0 && isAbsolute) {\n                ret.base = ret.name = path.slice(1, end);\n            } else {\n                ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        ret.base = ret.base || \"/\";\n    } else {\n        if (startPart === 0 && isAbsolute) {\n            ret.name = path.slice(1, startDot);\n            ret.base = path.slice(1, end);\n        } else {\n            ret.name = path.slice(startPart, startDot);\n            ret.base = path.slice(startPart, end);\n        }\n        ret.ext = path.slice(startDot, end);\n    }\n    if (startPart > 0) {\n        ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);\n    } else if (isAbsolute) ret.dir = \"/\";\n    return ret;\n}\nfunction fromFileUrl1(url) {\n    url = url instanceof URL ? url : new URL(url);\n    if (url.protocol != \"file:\") {\n        throw new TypeError(\"Must be a file URL.\");\n    }\n    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"));\n}\nfunction toFileUrl1(path) {\n    if (!isAbsolute1(path)) {\n        throw new TypeError(\"Must be an absolute path.\");\n    }\n    const url = new URL(\"file:///\");\n    url.pathname = encodeWhitespace(path.replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"));\n    return url;\n}\nconst mod1 = {\n    sep: sep1,\n    delimiter: delimiter1,\n    resolve: resolve1,\n    normalize: normalize1,\n    isAbsolute: isAbsolute1,\n    join: join1,\n    relative: relative1,\n    toNamespacedPath: toNamespacedPath1,\n    dirname: dirname1,\n    basename: basename1,\n    extname: extname1,\n    format: format1,\n    parse: parse1,\n    fromFileUrl: fromFileUrl1,\n    toFileUrl: toFileUrl1\n};\nconst path = isWindows ? mod : mod1;\nconst { join: join2 , normalize: normalize2  } = path;\nconst path1 = isWindows ? mod : mod1;\nconst { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2  } = path1;\nasync function exists(path, options) {\n    try {\n        const stat = await Deno.stat(path);\n        if (options && (options.isReadable || options.isDirectory || options.isFile)) {\n            if (options.isDirectory && options.isFile) {\n                throw new TypeError(\"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.\");\n            }\n            if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {\n                return false;\n            }\n            if (options.isReadable) {\n                if (stat.mode == null) {\n                    return true;\n                }\n                if (Deno.uid() == stat.uid) {\n                    return (stat.mode & 0o400) == 0o400;\n                } else if (Deno.gid() == stat.gid) {\n                    return (stat.mode & 0o040) == 0o040;\n                }\n                return (stat.mode & 0o004) == 0o004;\n            }\n        }\n        return true;\n    } catch (error) {\n        if (error instanceof Deno.errors.NotFound) {\n            return false;\n        }\n        if (error instanceof Deno.errors.PermissionDenied) {\n            if ((await Deno.permissions.query({\n                name: \"read\",\n                path\n            })).state === \"granted\") {\n                return !options?.isReadable;\n            }\n        }\n        throw error;\n    }\n}\nnew Deno.errors.AlreadyExists(\"dest already exists.\");\nvar EOL;\n(function(EOL) {\n    EOL[\"LF\"] = \"\\n\";\n    EOL[\"CRLF\"] = \"\\r\\n\";\n})(EOL || (EOL = {}));\nclass LangAdapter {\n    putAdapter;\n    #storagePath;\n    constructor(context){\n        if (\"storagePath\" in context.customSettings) {\n            this.#storagePath = context.customSettings[\"storagePath\"];\n        } else {\n            this.#storagePath = \"./tst-tmp/languages\";\n        }\n    }\n    async getLanguageSource(address) {\n        const bundlePath = join3(this.#storagePath, `bundle-${address}.js`);\n        try {\n            await exists(bundlePath);\n            const metaFile = Deno.readTextFileSync(bundlePath);\n            return metaFile;\n        } catch  {\n            throw new Error(\"Did not find language source for given address:\" + address);\n        }\n    }\n}\nclass PutAdapter {\n    #agent;\n    #storagePath;\n    constructor(context){\n        this.#agent = context.agent;\n        if (\"storagePath\" in context.customSettings) {\n            this.#storagePath = context.customSettings[\"storagePath\"];\n        } else {\n            this.#storagePath = \"./tst-tmp/languages\";\n        }\n    }\n    async createPublic(language) {\n        const hash = UTILS.hash(language.bundle.toString());\n        if (hash != language.meta.address) throw new Error(`Language Persistence: Can't store language. Address stated in meta differs from actual file\\nWanted: ${language.meta.address}\\nGot: ${hash}`);\n        const agent = this.#agent;\n        const expression = agent.createSignedExpression(language.meta);\n        const metaPath = join3(this.#storagePath, `meta-${hash}.json`);\n        const bundlePath = join3(this.#storagePath, `bundle-${hash}.js`);\n        console.log(\"Writing meta & bundle path: \", metaPath, bundlePath);\n        Deno.writeTextFileSync(metaPath, JSON.stringify(expression));\n        Deno.writeTextFileSync(bundlePath, language.bundle.toString());\n        return hash;\n    }\n}\nclass Adapter {\n    putAdapter;\n    #storagePath;\n    constructor(context){\n        this.putAdapter = new PutAdapter(context);\n        if (\"storagePath\" in context.customSettings) {\n            this.#storagePath = context.customSettings[\"storagePath\"];\n        } else {\n            this.#storagePath = \"./tst-tmp/languages\";\n        }\n    }\n    async get(address) {\n        const metaPath = join3(this.#storagePath, `meta-${address}.json`);\n        try {\n            await exists(metaPath);\n            const metaFile = JSON.parse(Deno.readTextFileSync(metaPath));\n            console.log(\"Found meta file info\", metaFile);\n            return metaFile;\n        } catch  {\n            return null;\n        }\n    }\n}\nconst name = \"languages\";\nfunction interactions(expression) {\n    return [];\n}\nasync function create(context) {\n    const expressionAdapter = new Adapter(context);\n    const languageAdapter = new LangAdapter(context);\n    return {\n        name,\n        expressionAdapter,\n        languageAdapter,\n        interactions\n    };\n}\nexport { name as name };\nexport { create as default };\n"}