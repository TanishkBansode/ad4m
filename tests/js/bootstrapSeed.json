{"trustedAgents":["did:key:zQ3shkkuZLvqeFgHdgZgFMUx8VGkgVWsLA83w2oekhZxoCW2n","did:key:z6MktfNXQq4NQ6acoHwqjVTH1h6rTzj7gHaJbCcrK3uzVBFR","did:key:z6MkkminW2vZnQmguou26cQfDg8SpW7q6eFU5r3onXNobVXp","did:key:z6MkjmBkwarDdQwmU11FnD74hJHPC7beWS1JHCeHv875Yviu","did:key:z6MktzQVR74GcRoe27XXytUPSRd15Ddme43fnZRyGdsNahDh","did:key:z6Mkpf24K4VqN6bV5wKX58SSugkoGXoRve9xkdMLotDeihqe","did:key:z6MkvTtZTEG1uZkzkGda23AYTyJ47hMXiX1gHhayVNNBz186","did:key:z6MkhiGFS8Hh2VHzmXfk4noM9Bd4BrzVP57NdspkuxpdXbLM"],"knownLinkLanguages":["QmzSYwdi388fegfXhzNmddHob7dGeEH61v8v6YpmqEA31SFw19B"],"directMessageLanguage":"QmzSYwdePqjD3uuZiKNGLy32XHWEeHKY61vU5knzAQw9PtC7cxJ","agentLanguage":"QmzSYwdZfxLvW1DkEEqDG66roy3pBNakmZwiKBM6g3n8HQZJndE","perspectiveLanguage":"QmzSYwddxFCzVD63LgR8MTBaUEcwf9jhB3XjLbYBp2q8V1MqVtS","neighbourhoodLanguage":"QmzSYwdjgDBV1mpq42HXF6RzubNbwoSiFVZeQevJU3Rwa6hE5i5","languageLanguageBundle":"// deno-fmt-ignore-file\r\n// deno-lint-ignore-file\r\n// This code was bundled using `deno bundle` and it's not recommended to edit it manually\r\n\r\nconst osType = (()=>{\r\n    const { Deno: Deno1  } = globalThis;\r\n    if (typeof Deno1?.build?.os === \"string\") {\r\n        return Deno1.build.os;\r\n    }\r\n    const { navigator  } = globalThis;\r\n    if (navigator?.appVersion?.includes?.(\"Win\")) {\r\n        return \"windows\";\r\n    }\r\n    return \"linux\";\r\n})();\r\nconst isWindows = osType === \"windows\";\r\nconst CHAR_FORWARD_SLASH = 47;\r\nfunction assertPath(path) {\r\n    if (typeof path !== \"string\") {\r\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\r\n    }\r\n}\r\nfunction isPosixPathSeparator(code) {\r\n    return code === 47;\r\n}\r\nfunction isPathSeparator(code) {\r\n    return isPosixPathSeparator(code) || code === 92;\r\n}\r\nfunction isWindowsDeviceRoot(code) {\r\n    return code >= 97 && code <= 122 || code >= 65 && code <= 90;\r\n}\r\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\r\n    let res = \"\";\r\n    let lastSegmentLength = 0;\r\n    let lastSlash = -1;\r\n    let dots = 0;\r\n    let code;\r\n    for(let i = 0, len = path.length; i <= len; ++i){\r\n        if (i < len) code = path.charCodeAt(i);\r\n        else if (isPathSeparator(code)) break;\r\n        else code = CHAR_FORWARD_SLASH;\r\n        if (isPathSeparator(code)) {\r\n            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {\r\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\r\n                    if (res.length > 2) {\r\n                        const lastSlashIndex = res.lastIndexOf(separator);\r\n                        if (lastSlashIndex === -1) {\r\n                            res = \"\";\r\n                            lastSegmentLength = 0;\r\n                        } else {\r\n                            res = res.slice(0, lastSlashIndex);\r\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\r\n                        }\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    } else if (res.length === 2 || res.length === 1) {\r\n                        res = \"\";\r\n                        lastSegmentLength = 0;\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (allowAboveRoot) {\r\n                    if (res.length > 0) res += `${separator}..`;\r\n                    else res = \"..\";\r\n                    lastSegmentLength = 2;\r\n                }\r\n            } else {\r\n                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\r\n                else res = path.slice(lastSlash + 1, i);\r\n                lastSegmentLength = i - lastSlash - 1;\r\n            }\r\n            lastSlash = i;\r\n            dots = 0;\r\n        } else if (code === 46 && dots !== -1) {\r\n            ++dots;\r\n        } else {\r\n            dots = -1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction _format(sep, pathObject) {\r\n    const dir = pathObject.dir || pathObject.root;\r\n    const base = pathObject.base || (pathObject.name || \"\") + (pathObject.ext || \"\");\r\n    if (!dir) return base;\r\n    if (base === sep) return dir;\r\n    if (dir === pathObject.root) return dir + base;\r\n    return dir + sep + base;\r\n}\r\nconst WHITESPACE_ENCODINGS = {\r\n    \"\\u0009\": \"%09\",\r\n    \"\\u000A\": \"%0A\",\r\n    \"\\u000B\": \"%0B\",\r\n    \"\\u000C\": \"%0C\",\r\n    \"\\u000D\": \"%0D\",\r\n    \"\\u0020\": \"%20\"\r\n};\r\nfunction encodeWhitespace(string) {\r\n    return string.replaceAll(/[\\s]/g, (c)=>{\r\n        return WHITESPACE_ENCODINGS[c] ?? c;\r\n    });\r\n}\r\nfunction lastPathSegment(path, isSep, start = 0) {\r\n    let matchedNonSeparator = false;\r\n    let end = path.length;\r\n    for(let i = path.length - 1; i >= start; --i){\r\n        if (isSep(path.charCodeAt(i))) {\r\n            if (matchedNonSeparator) {\r\n                start = i + 1;\r\n                break;\r\n            }\r\n        } else if (!matchedNonSeparator) {\r\n            matchedNonSeparator = true;\r\n            end = i + 1;\r\n        }\r\n    }\r\n    return path.slice(start, end);\r\n}\r\nfunction stripTrailingSeparators(segment, isSep) {\r\n    if (segment.length <= 1) {\r\n        return segment;\r\n    }\r\n    let end = segment.length;\r\n    for(let i = segment.length - 1; i > 0; i--){\r\n        if (isSep(segment.charCodeAt(i))) {\r\n            end = i;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return segment.slice(0, end);\r\n}\r\nfunction stripSuffix(name, suffix) {\r\n    if (suffix.length >= name.length) {\r\n        return name;\r\n    }\r\n    const lenDiff = name.length - suffix.length;\r\n    for(let i = suffix.length - 1; i >= 0; --i){\r\n        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {\r\n            return name;\r\n        }\r\n    }\r\n    return name.slice(0, -suffix.length);\r\n}\r\nclass DenoStdInternalError extends Error {\r\n    constructor(message){\r\n        super(message);\r\n        this.name = \"DenoStdInternalError\";\r\n    }\r\n}\r\nfunction assert(expr, msg = \"\") {\r\n    if (!expr) {\r\n        throw new DenoStdInternalError(msg);\r\n    }\r\n}\r\nconst sep = \"\\\\\";\r\nconst delimiter = \";\";\r\nfunction resolve(...pathSegments) {\r\n    let resolvedDevice = \"\";\r\n    let resolvedTail = \"\";\r\n    let resolvedAbsolute = false;\r\n    for(let i = pathSegments.length - 1; i >= -1; i--){\r\n        let path;\r\n        const { Deno: Deno1  } = globalThis;\r\n        if (i >= 0) {\r\n            path = pathSegments[i];\r\n        } else if (!resolvedDevice) {\r\n            if (typeof Deno1?.cwd !== \"function\") {\r\n                throw new TypeError(\"Resolved a drive-letter-less path without a CWD.\");\r\n            }\r\n            path = Deno1.cwd();\r\n        } else {\r\n            if (typeof Deno1?.env?.get !== \"function\" || typeof Deno1?.cwd !== \"function\") {\r\n                throw new TypeError(\"Resolved a relative path without a CWD.\");\r\n            }\r\n            path = Deno1.cwd();\r\n            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\\\`) {\r\n                path = `${resolvedDevice}\\\\`;\r\n            }\r\n        }\r\n        assertPath(path);\r\n        const len = path.length;\r\n        if (len === 0) continue;\r\n        let rootEnd = 0;\r\n        let device = \"\";\r\n        let isAbsolute = false;\r\n        const code = path.charCodeAt(0);\r\n        if (len > 1) {\r\n            if (isPathSeparator(code)) {\r\n                isAbsolute = true;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    let j = 2;\r\n                    let last = j;\r\n                    for(; j < len; ++j){\r\n                        if (isPathSeparator(path.charCodeAt(j))) break;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        const firstPart = path.slice(last, j);\r\n                        last = j;\r\n                        for(; j < len; ++j){\r\n                            if (!isPathSeparator(path.charCodeAt(j))) break;\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            last = j;\r\n                            for(; j < len; ++j){\r\n                                if (isPathSeparator(path.charCodeAt(j))) break;\r\n                            }\r\n                            if (j === len) {\r\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last)}`;\r\n                                rootEnd = j;\r\n                            } else if (j !== last) {\r\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                                rootEnd = j;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    rootEnd = 1;\r\n                }\r\n            } else if (isWindowsDeviceRoot(code)) {\r\n                if (path.charCodeAt(1) === 58) {\r\n                    device = path.slice(0, 2);\r\n                    rootEnd = 2;\r\n                    if (len > 2) {\r\n                        if (isPathSeparator(path.charCodeAt(2))) {\r\n                            isAbsolute = true;\r\n                            rootEnd = 3;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (isPathSeparator(code)) {\r\n            rootEnd = 1;\r\n            isAbsolute = true;\r\n        }\r\n        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n            continue;\r\n        }\r\n        if (resolvedDevice.length === 0 && device.length > 0) {\r\n            resolvedDevice = device;\r\n        }\r\n        if (!resolvedAbsolute) {\r\n            resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\r\n            resolvedAbsolute = isAbsolute;\r\n        }\r\n        if (resolvedAbsolute && resolvedDevice.length > 0) break;\r\n    }\r\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, \"\\\\\", isPathSeparator);\r\n    return resolvedDevice + (resolvedAbsolute ? \"\\\\\" : \"\") + resolvedTail || \".\";\r\n}\r\nfunction normalize(path) {\r\n    assertPath(path);\r\n    const len = path.length;\r\n    if (len === 0) return \".\";\r\n    let rootEnd = 0;\r\n    let device;\r\n    let isAbsolute = false;\r\n    const code = path.charCodeAt(0);\r\n    if (len > 1) {\r\n        if (isPathSeparator(code)) {\r\n            isAbsolute = true;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                let j = 2;\r\n                let last = j;\r\n                for(; j < len; ++j){\r\n                    if (isPathSeparator(path.charCodeAt(j))) break;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    const firstPart = path.slice(last, j);\r\n                    last = j;\r\n                    for(; j < len; ++j){\r\n                        if (!isPathSeparator(path.charCodeAt(j))) break;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        last = j;\r\n                        for(; j < len; ++j){\r\n                            if (isPathSeparator(path.charCodeAt(j))) break;\r\n                        }\r\n                        if (j === len) {\r\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\r\n                        } else if (j !== last) {\r\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                            rootEnd = j;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                rootEnd = 1;\r\n            }\r\n        } else if (isWindowsDeviceRoot(code)) {\r\n            if (path.charCodeAt(1) === 58) {\r\n                device = path.slice(0, 2);\r\n                rootEnd = 2;\r\n                if (len > 2) {\r\n                    if (isPathSeparator(path.charCodeAt(2))) {\r\n                        isAbsolute = true;\r\n                        rootEnd = 3;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else if (isPathSeparator(code)) {\r\n        return \"\\\\\";\r\n    }\r\n    let tail;\r\n    if (rootEnd < len) {\r\n        tail = normalizeString(path.slice(rootEnd), !isAbsolute, \"\\\\\", isPathSeparator);\r\n    } else {\r\n        tail = \"\";\r\n    }\r\n    if (tail.length === 0 && !isAbsolute) tail = \".\";\r\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\r\n        tail += \"\\\\\";\r\n    }\r\n    if (device === undefined) {\r\n        if (isAbsolute) {\r\n            if (tail.length > 0) return `\\\\${tail}`;\r\n            else return \"\\\\\";\r\n        } else if (tail.length > 0) {\r\n            return tail;\r\n        } else {\r\n            return \"\";\r\n        }\r\n    } else if (isAbsolute) {\r\n        if (tail.length > 0) return `${device}\\\\${tail}`;\r\n        else return `${device}\\\\`;\r\n    } else if (tail.length > 0) {\r\n        return device + tail;\r\n    } else {\r\n        return device;\r\n    }\r\n}\r\nfunction isAbsolute(path) {\r\n    assertPath(path);\r\n    const len = path.length;\r\n    if (len === 0) return false;\r\n    const code = path.charCodeAt(0);\r\n    if (isPathSeparator(code)) {\r\n        return true;\r\n    } else if (isWindowsDeviceRoot(code)) {\r\n        if (len > 2 && path.charCodeAt(1) === 58) {\r\n            if (isPathSeparator(path.charCodeAt(2))) return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction join(...paths) {\r\n    const pathsCount = paths.length;\r\n    if (pathsCount === 0) return \".\";\r\n    let joined;\r\n    let firstPart = null;\r\n    for(let i = 0; i < pathsCount; ++i){\r\n        const path = paths[i];\r\n        assertPath(path);\r\n        if (path.length > 0) {\r\n            if (joined === undefined) joined = firstPart = path;\r\n            else joined += `\\\\${path}`;\r\n        }\r\n    }\r\n    if (joined === undefined) return \".\";\r\n    let needsReplace = true;\r\n    let slashCount = 0;\r\n    assert(firstPart != null);\r\n    if (isPathSeparator(firstPart.charCodeAt(0))) {\r\n        ++slashCount;\r\n        const firstLen = firstPart.length;\r\n        if (firstLen > 1) {\r\n            if (isPathSeparator(firstPart.charCodeAt(1))) {\r\n                ++slashCount;\r\n                if (firstLen > 2) {\r\n                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;\r\n                    else {\r\n                        needsReplace = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (needsReplace) {\r\n        for(; slashCount < joined.length; ++slashCount){\r\n            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;\r\n        }\r\n        if (slashCount >= 2) joined = `\\\\${joined.slice(slashCount)}`;\r\n    }\r\n    return normalize(joined);\r\n}\r\nfunction relative(from, to) {\r\n    assertPath(from);\r\n    assertPath(to);\r\n    if (from === to) return \"\";\r\n    const fromOrig = resolve(from);\r\n    const toOrig = resolve(to);\r\n    if (fromOrig === toOrig) return \"\";\r\n    from = fromOrig.toLowerCase();\r\n    to = toOrig.toLowerCase();\r\n    if (from === to) return \"\";\r\n    let fromStart = 0;\r\n    let fromEnd = from.length;\r\n    for(; fromStart < fromEnd; ++fromStart){\r\n        if (from.charCodeAt(fromStart) !== 92) break;\r\n    }\r\n    for(; fromEnd - 1 > fromStart; --fromEnd){\r\n        if (from.charCodeAt(fromEnd - 1) !== 92) break;\r\n    }\r\n    const fromLen = fromEnd - fromStart;\r\n    let toStart = 0;\r\n    let toEnd = to.length;\r\n    for(; toStart < toEnd; ++toStart){\r\n        if (to.charCodeAt(toStart) !== 92) break;\r\n    }\r\n    for(; toEnd - 1 > toStart; --toEnd){\r\n        if (to.charCodeAt(toEnd - 1) !== 92) break;\r\n    }\r\n    const toLen = toEnd - toStart;\r\n    const length = fromLen < toLen ? fromLen : toLen;\r\n    let lastCommonSep = -1;\r\n    let i = 0;\r\n    for(; i <= length; ++i){\r\n        if (i === length) {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === 92) {\r\n                    return toOrig.slice(toStart + i + 1);\r\n                } else if (i === 2) {\r\n                    return toOrig.slice(toStart + i);\r\n                }\r\n            }\r\n            if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === 92) {\r\n                    lastCommonSep = i;\r\n                } else if (i === 2) {\r\n                    lastCommonSep = 3;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        const fromCode = from.charCodeAt(fromStart + i);\r\n        const toCode = to.charCodeAt(toStart + i);\r\n        if (fromCode !== toCode) break;\r\n        else if (fromCode === 92) lastCommonSep = i;\r\n    }\r\n    if (i !== length && lastCommonSep === -1) {\r\n        return toOrig;\r\n    }\r\n    let out = \"\";\r\n    if (lastCommonSep === -1) lastCommonSep = 0;\r\n    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){\r\n        if (i === fromEnd || from.charCodeAt(i) === 92) {\r\n            if (out.length === 0) out += \"..\";\r\n            else out += \"\\\\..\";\r\n        }\r\n    }\r\n    if (out.length > 0) {\r\n        return out + toOrig.slice(toStart + lastCommonSep, toEnd);\r\n    } else {\r\n        toStart += lastCommonSep;\r\n        if (toOrig.charCodeAt(toStart) === 92) ++toStart;\r\n        return toOrig.slice(toStart, toEnd);\r\n    }\r\n}\r\nfunction toNamespacedPath(path) {\r\n    if (typeof path !== \"string\") return path;\r\n    if (path.length === 0) return \"\";\r\n    const resolvedPath = resolve(path);\r\n    if (resolvedPath.length >= 3) {\r\n        if (resolvedPath.charCodeAt(0) === 92) {\r\n            if (resolvedPath.charCodeAt(1) === 92) {\r\n                const code = resolvedPath.charCodeAt(2);\r\n                if (code !== 63 && code !== 46) {\r\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\r\n                }\r\n            }\r\n        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\r\n            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {\r\n                return `\\\\\\\\?\\\\${resolvedPath}`;\r\n            }\r\n        }\r\n    }\r\n    return path;\r\n}\r\nfunction dirname(path) {\r\n    assertPath(path);\r\n    const len = path.length;\r\n    if (len === 0) return \".\";\r\n    let rootEnd = -1;\r\n    let end = -1;\r\n    let matchedSlash = true;\r\n    let offset = 0;\r\n    const code = path.charCodeAt(0);\r\n    if (len > 1) {\r\n        if (isPathSeparator(code)) {\r\n            rootEnd = offset = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                let j = 2;\r\n                let last = j;\r\n                for(; j < len; ++j){\r\n                    if (isPathSeparator(path.charCodeAt(j))) break;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    last = j;\r\n                    for(; j < len; ++j){\r\n                        if (!isPathSeparator(path.charCodeAt(j))) break;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        last = j;\r\n                        for(; j < len; ++j){\r\n                            if (isPathSeparator(path.charCodeAt(j))) break;\r\n                        }\r\n                        if (j === len) {\r\n                            return path;\r\n                        }\r\n                        if (j !== last) {\r\n                            rootEnd = offset = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (isWindowsDeviceRoot(code)) {\r\n            if (path.charCodeAt(1) === 58) {\r\n                rootEnd = offset = 2;\r\n                if (len > 2) {\r\n                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;\r\n                }\r\n            }\r\n        }\r\n    } else if (isPathSeparator(code)) {\r\n        return path;\r\n    }\r\n    for(let i = len - 1; i >= offset; --i){\r\n        if (isPathSeparator(path.charCodeAt(i))) {\r\n            if (!matchedSlash) {\r\n                end = i;\r\n                break;\r\n            }\r\n        } else {\r\n            matchedSlash = false;\r\n        }\r\n    }\r\n    if (end === -1) {\r\n        if (rootEnd === -1) return \".\";\r\n        else end = rootEnd;\r\n    }\r\n    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\r\n}\r\nfunction basename(path, suffix = \"\") {\r\n    assertPath(path);\r\n    if (path.length === 0) return path;\r\n    if (typeof suffix !== \"string\") {\r\n        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);\r\n    }\r\n    let start = 0;\r\n    if (path.length >= 2) {\r\n        const drive = path.charCodeAt(0);\r\n        if (isWindowsDeviceRoot(drive)) {\r\n            if (path.charCodeAt(1) === 58) start = 2;\r\n        }\r\n    }\r\n    const lastSegment = lastPathSegment(path, isPathSeparator, start);\r\n    const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);\r\n    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\r\n}\r\nfunction extname(path) {\r\n    assertPath(path);\r\n    let start = 0;\r\n    let startDot = -1;\r\n    let startPart = 0;\r\n    let end = -1;\r\n    let matchedSlash = true;\r\n    let preDotState = 0;\r\n    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {\r\n        start = startPart = 2;\r\n    }\r\n    for(let i = path.length - 1; i >= start; --i){\r\n        const code = path.charCodeAt(i);\r\n        if (isPathSeparator(code)) {\r\n            if (!matchedSlash) {\r\n                startPart = i + 1;\r\n                break;\r\n            }\r\n            continue;\r\n        }\r\n        if (end === -1) {\r\n            matchedSlash = false;\r\n            end = i + 1;\r\n        }\r\n        if (code === 46) {\r\n            if (startDot === -1) startDot = i;\r\n            else if (preDotState !== 1) preDotState = 1;\r\n        } else if (startDot !== -1) {\r\n            preDotState = -1;\r\n        }\r\n    }\r\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\r\n        return \"\";\r\n    }\r\n    return path.slice(startDot, end);\r\n}\r\nfunction format(pathObject) {\r\n    if (pathObject === null || typeof pathObject !== \"object\") {\r\n        throw new TypeError(`The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`);\r\n    }\r\n    return _format(\"\\\\\", pathObject);\r\n}\r\nfunction parse(path) {\r\n    assertPath(path);\r\n    const ret = {\r\n        root: \"\",\r\n        dir: \"\",\r\n        base: \"\",\r\n        ext: \"\",\r\n        name: \"\"\r\n    };\r\n    const len = path.length;\r\n    if (len === 0) return ret;\r\n    let rootEnd = 0;\r\n    let code = path.charCodeAt(0);\r\n    if (len > 1) {\r\n        if (isPathSeparator(code)) {\r\n            rootEnd = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                let j = 2;\r\n                let last = j;\r\n                for(; j < len; ++j){\r\n                    if (isPathSeparator(path.charCodeAt(j))) break;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    last = j;\r\n                    for(; j < len; ++j){\r\n                        if (!isPathSeparator(path.charCodeAt(j))) break;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        last = j;\r\n                        for(; j < len; ++j){\r\n                            if (isPathSeparator(path.charCodeAt(j))) break;\r\n                        }\r\n                        if (j === len) {\r\n                            rootEnd = j;\r\n                        } else if (j !== last) {\r\n                            rootEnd = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (isWindowsDeviceRoot(code)) {\r\n            if (path.charCodeAt(1) === 58) {\r\n                rootEnd = 2;\r\n                if (len > 2) {\r\n                    if (isPathSeparator(path.charCodeAt(2))) {\r\n                        if (len === 3) {\r\n                            ret.root = ret.dir = path;\r\n                            ret.base = \"\\\\\";\r\n                            return ret;\r\n                        }\r\n                        rootEnd = 3;\r\n                    }\r\n                } else {\r\n                    ret.root = ret.dir = path;\r\n                    return ret;\r\n                }\r\n            }\r\n        }\r\n    } else if (isPathSeparator(code)) {\r\n        ret.root = ret.dir = path;\r\n        ret.base = \"\\\\\";\r\n        return ret;\r\n    }\r\n    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);\r\n    let startDot = -1;\r\n    let startPart = rootEnd;\r\n    let end = -1;\r\n    let matchedSlash = true;\r\n    let i = path.length - 1;\r\n    let preDotState = 0;\r\n    for(; i >= rootEnd; --i){\r\n        code = path.charCodeAt(i);\r\n        if (isPathSeparator(code)) {\r\n            if (!matchedSlash) {\r\n                startPart = i + 1;\r\n                break;\r\n            }\r\n            continue;\r\n        }\r\n        if (end === -1) {\r\n            matchedSlash = false;\r\n            end = i + 1;\r\n        }\r\n        if (code === 46) {\r\n            if (startDot === -1) startDot = i;\r\n            else if (preDotState !== 1) preDotState = 1;\r\n        } else if (startDot !== -1) {\r\n            preDotState = -1;\r\n        }\r\n    }\r\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\r\n        if (end !== -1) {\r\n            ret.base = ret.name = path.slice(startPart, end);\r\n        }\r\n    } else {\r\n        ret.name = path.slice(startPart, startDot);\r\n        ret.base = path.slice(startPart, end);\r\n        ret.ext = path.slice(startDot, end);\r\n    }\r\n    ret.base = ret.base || \"\\\\\";\r\n    if (startPart > 0 && startPart !== rootEnd) {\r\n        ret.dir = path.slice(0, startPart - 1);\r\n    } else ret.dir = ret.root;\r\n    return ret;\r\n}\r\nfunction fromFileUrl(url) {\r\n    url = url instanceof URL ? url : new URL(url);\r\n    if (url.protocol != \"file:\") {\r\n        throw new TypeError(\"Must be a file URL.\");\r\n    }\r\n    let path = decodeURIComponent(url.pathname.replace(/\\//g, \"\\\\\").replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\")).replace(/^\\\\*([A-Za-z]:)(\\\\|$)/, \"$1\\\\\");\r\n    if (url.hostname != \"\") {\r\n        path = `\\\\\\\\${url.hostname}${path}`;\r\n    }\r\n    return path;\r\n}\r\nfunction toFileUrl(path) {\r\n    if (!isAbsolute(path)) {\r\n        throw new TypeError(\"Must be an absolute path.\");\r\n    }\r\n    const [, hostname, pathname] = path.match(/^(?:[/\\\\]{2}([^/\\\\]+)(?=[/\\\\](?:[^/\\\\]|$)))?(.*)/);\r\n    const url = new URL(\"file:///\");\r\n    url.pathname = encodeWhitespace(pathname.replace(/%/g, \"%25\"));\r\n    if (hostname != null && hostname != \"localhost\") {\r\n        url.hostname = hostname;\r\n        if (!url.hostname) {\r\n            throw new TypeError(\"Invalid hostname.\");\r\n        }\r\n    }\r\n    return url;\r\n}\r\nconst mod = {\r\n    sep: sep,\r\n    delimiter: delimiter,\r\n    resolve: resolve,\r\n    normalize: normalize,\r\n    isAbsolute: isAbsolute,\r\n    join: join,\r\n    relative: relative,\r\n    toNamespacedPath: toNamespacedPath,\r\n    dirname: dirname,\r\n    basename: basename,\r\n    extname: extname,\r\n    format: format,\r\n    parse: parse,\r\n    fromFileUrl: fromFileUrl,\r\n    toFileUrl: toFileUrl\r\n};\r\nconst sep1 = \"/\";\r\nconst delimiter1 = \":\";\r\nfunction resolve1(...pathSegments) {\r\n    let resolvedPath = \"\";\r\n    let resolvedAbsolute = false;\r\n    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){\r\n        let path;\r\n        if (i >= 0) path = pathSegments[i];\r\n        else {\r\n            const { Deno: Deno1  } = globalThis;\r\n            if (typeof Deno1?.cwd !== \"function\") {\r\n                throw new TypeError(\"Resolved a relative path without a CWD.\");\r\n            }\r\n            path = Deno1.cwd();\r\n        }\r\n        assertPath(path);\r\n        if (path.length === 0) {\r\n            continue;\r\n        }\r\n        resolvedPath = `${path}/${resolvedPath}`;\r\n        resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));\r\n    }\r\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, \"/\", isPosixPathSeparator);\r\n    if (resolvedAbsolute) {\r\n        if (resolvedPath.length > 0) return `/${resolvedPath}`;\r\n        else return \"/\";\r\n    } else if (resolvedPath.length > 0) return resolvedPath;\r\n    else return \".\";\r\n}\r\nfunction normalize1(path) {\r\n    assertPath(path);\r\n    if (path.length === 0) return \".\";\r\n    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\r\n    const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));\r\n    path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\r\n    if (path.length === 0 && !isAbsolute) path = \".\";\r\n    if (path.length > 0 && trailingSeparator) path += \"/\";\r\n    if (isAbsolute) return `/${path}`;\r\n    return path;\r\n}\r\nfunction isAbsolute1(path) {\r\n    assertPath(path);\r\n    return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));\r\n}\r\nfunction join1(...paths) {\r\n    if (paths.length === 0) return \".\";\r\n    let joined;\r\n    for(let i = 0, len = paths.length; i < len; ++i){\r\n        const path = paths[i];\r\n        assertPath(path);\r\n        if (path.length > 0) {\r\n            if (!joined) joined = path;\r\n            else joined += `/${path}`;\r\n        }\r\n    }\r\n    if (!joined) return \".\";\r\n    return normalize1(joined);\r\n}\r\nfunction relative1(from, to) {\r\n    assertPath(from);\r\n    assertPath(to);\r\n    if (from === to) return \"\";\r\n    from = resolve1(from);\r\n    to = resolve1(to);\r\n    if (from === to) return \"\";\r\n    let fromStart = 1;\r\n    const fromEnd = from.length;\r\n    for(; fromStart < fromEnd; ++fromStart){\r\n        if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;\r\n    }\r\n    const fromLen = fromEnd - fromStart;\r\n    let toStart = 1;\r\n    const toEnd = to.length;\r\n    for(; toStart < toEnd; ++toStart){\r\n        if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;\r\n    }\r\n    const toLen = toEnd - toStart;\r\n    const length = fromLen < toLen ? fromLen : toLen;\r\n    let lastCommonSep = -1;\r\n    let i = 0;\r\n    for(; i <= length; ++i){\r\n        if (i === length) {\r\n            if (toLen > length) {\r\n                if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {\r\n                    return to.slice(toStart + i + 1);\r\n                } else if (i === 0) {\r\n                    return to.slice(toStart + i);\r\n                }\r\n            } else if (fromLen > length) {\r\n                if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {\r\n                    lastCommonSep = i;\r\n                } else if (i === 0) {\r\n                    lastCommonSep = 0;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        const fromCode = from.charCodeAt(fromStart + i);\r\n        const toCode = to.charCodeAt(toStart + i);\r\n        if (fromCode !== toCode) break;\r\n        else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;\r\n    }\r\n    let out = \"\";\r\n    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){\r\n        if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {\r\n            if (out.length === 0) out += \"..\";\r\n            else out += \"/..\";\r\n        }\r\n    }\r\n    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\r\n    else {\r\n        toStart += lastCommonSep;\r\n        if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;\r\n        return to.slice(toStart);\r\n    }\r\n}\r\nfunction toNamespacedPath1(path) {\r\n    return path;\r\n}\r\nfunction dirname1(path) {\r\n    if (path.length === 0) return \".\";\r\n    let end = -1;\r\n    let matchedNonSeparator = false;\r\n    for(let i = path.length - 1; i >= 1; --i){\r\n        if (isPosixPathSeparator(path.charCodeAt(i))) {\r\n            if (matchedNonSeparator) {\r\n                end = i;\r\n                break;\r\n            }\r\n        } else {\r\n            matchedNonSeparator = true;\r\n        }\r\n    }\r\n    if (end === -1) {\r\n        return isPosixPathSeparator(path.charCodeAt(0)) ? \"/\" : \".\";\r\n    }\r\n    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\r\n}\r\nfunction basename1(path, suffix = \"\") {\r\n    assertPath(path);\r\n    if (path.length === 0) return path;\r\n    if (typeof suffix !== \"string\") {\r\n        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);\r\n    }\r\n    const lastSegment = lastPathSegment(path, isPosixPathSeparator);\r\n    const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);\r\n    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\r\n}\r\nfunction extname1(path) {\r\n    assertPath(path);\r\n    let startDot = -1;\r\n    let startPart = 0;\r\n    let end = -1;\r\n    let matchedSlash = true;\r\n    let preDotState = 0;\r\n    for(let i = path.length - 1; i >= 0; --i){\r\n        const code = path.charCodeAt(i);\r\n        if (isPosixPathSeparator(code)) {\r\n            if (!matchedSlash) {\r\n                startPart = i + 1;\r\n                break;\r\n            }\r\n            continue;\r\n        }\r\n        if (end === -1) {\r\n            matchedSlash = false;\r\n            end = i + 1;\r\n        }\r\n        if (code === 46) {\r\n            if (startDot === -1) startDot = i;\r\n            else if (preDotState !== 1) preDotState = 1;\r\n        } else if (startDot !== -1) {\r\n            preDotState = -1;\r\n        }\r\n    }\r\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\r\n        return \"\";\r\n    }\r\n    return path.slice(startDot, end);\r\n}\r\nfunction format1(pathObject) {\r\n    if (pathObject === null || typeof pathObject !== \"object\") {\r\n        throw new TypeError(`The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`);\r\n    }\r\n    return _format(\"/\", pathObject);\r\n}\r\nfunction parse1(path) {\r\n    assertPath(path);\r\n    const ret = {\r\n        root: \"\",\r\n        dir: \"\",\r\n        base: \"\",\r\n        ext: \"\",\r\n        name: \"\"\r\n    };\r\n    if (path.length === 0) return ret;\r\n    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\r\n    let start;\r\n    if (isAbsolute) {\r\n        ret.root = \"/\";\r\n        start = 1;\r\n    } else {\r\n        start = 0;\r\n    }\r\n    let startDot = -1;\r\n    let startPart = 0;\r\n    let end = -1;\r\n    let matchedSlash = true;\r\n    let i = path.length - 1;\r\n    let preDotState = 0;\r\n    for(; i >= start; --i){\r\n        const code = path.charCodeAt(i);\r\n        if (isPosixPathSeparator(code)) {\r\n            if (!matchedSlash) {\r\n                startPart = i + 1;\r\n                break;\r\n            }\r\n            continue;\r\n        }\r\n        if (end === -1) {\r\n            matchedSlash = false;\r\n            end = i + 1;\r\n        }\r\n        if (code === 46) {\r\n            if (startDot === -1) startDot = i;\r\n            else if (preDotState !== 1) preDotState = 1;\r\n        } else if (startDot !== -1) {\r\n            preDotState = -1;\r\n        }\r\n    }\r\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\r\n        if (end !== -1) {\r\n            if (startPart === 0 && isAbsolute) {\r\n                ret.base = ret.name = path.slice(1, end);\r\n            } else {\r\n                ret.base = ret.name = path.slice(startPart, end);\r\n            }\r\n        }\r\n        ret.base = ret.base || \"/\";\r\n    } else {\r\n        if (startPart === 0 && isAbsolute) {\r\n            ret.name = path.slice(1, startDot);\r\n            ret.base = path.slice(1, end);\r\n        } else {\r\n            ret.name = path.slice(startPart, startDot);\r\n            ret.base = path.slice(startPart, end);\r\n        }\r\n        ret.ext = path.slice(startDot, end);\r\n    }\r\n    if (startPart > 0) {\r\n        ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);\r\n    } else if (isAbsolute) ret.dir = \"/\";\r\n    return ret;\r\n}\r\nfunction fromFileUrl1(url) {\r\n    url = url instanceof URL ? url : new URL(url);\r\n    if (url.protocol != \"file:\") {\r\n        throw new TypeError(\"Must be a file URL.\");\r\n    }\r\n    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"));\r\n}\r\nfunction toFileUrl1(path) {\r\n    if (!isAbsolute1(path)) {\r\n        throw new TypeError(\"Must be an absolute path.\");\r\n    }\r\n    const url = new URL(\"file:///\");\r\n    url.pathname = encodeWhitespace(path.replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"));\r\n    return url;\r\n}\r\nconst mod1 = {\r\n    sep: sep1,\r\n    delimiter: delimiter1,\r\n    resolve: resolve1,\r\n    normalize: normalize1,\r\n    isAbsolute: isAbsolute1,\r\n    join: join1,\r\n    relative: relative1,\r\n    toNamespacedPath: toNamespacedPath1,\r\n    dirname: dirname1,\r\n    basename: basename1,\r\n    extname: extname1,\r\n    format: format1,\r\n    parse: parse1,\r\n    fromFileUrl: fromFileUrl1,\r\n    toFileUrl: toFileUrl1\r\n};\r\nconst path = isWindows ? mod : mod1;\r\nconst { join: join2 , normalize: normalize2  } = path;\r\nconst path1 = isWindows ? mod : mod1;\r\nconst { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2  } = path1;\r\nasync function exists(path, options) {\r\n    try {\r\n        const stat = await Deno.stat(path);\r\n        if (options && (options.isReadable || options.isDirectory || options.isFile)) {\r\n            if (options.isDirectory && options.isFile) {\r\n                throw new TypeError(\"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.\");\r\n            }\r\n            if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {\r\n                return false;\r\n            }\r\n            if (options.isReadable) {\r\n                if (stat.mode == null) {\r\n                    return true;\r\n                }\r\n                if (Deno.uid() == stat.uid) {\r\n                    return (stat.mode & 0o400) == 0o400;\r\n                } else if (Deno.gid() == stat.gid) {\r\n                    return (stat.mode & 0o040) == 0o040;\r\n                }\r\n                return (stat.mode & 0o004) == 0o004;\r\n            }\r\n        }\r\n        return true;\r\n    } catch (error) {\r\n        if (error instanceof Deno.errors.NotFound) {\r\n            return false;\r\n        }\r\n        if (error instanceof Deno.errors.PermissionDenied) {\r\n            if ((await Deno.permissions.query({\r\n                name: \"read\",\r\n                path\r\n            })).state === \"granted\") {\r\n                return !options?.isReadable;\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\nnew Deno.errors.AlreadyExists(\"dest already exists.\");\r\nvar EOL;\r\n(function(EOL) {\r\n    EOL[\"LF\"] = \"\\n\";\r\n    EOL[\"CRLF\"] = \"\\r\\n\";\r\n})(EOL || (EOL = {}));\r\nclass LangAdapter {\r\n    putAdapter;\r\n    #storagePath;\r\n    constructor(context){\r\n        if (\"storagePath\" in context.customSettings) {\r\n            this.#storagePath = context.customSettings[\"storagePath\"];\r\n        } else {\r\n            this.#storagePath = \"./tst-tmp/languages\";\r\n        }\r\n    }\r\n    async getLanguageSource(address) {\r\n        const bundlePath = join3(this.#storagePath, `bundle-${address}.js`);\r\n        try {\r\n            await exists(bundlePath);\r\n            const metaFile = Deno.readTextFileSync(bundlePath);\r\n            return metaFile;\r\n        } catch  {\r\n            throw new Error(\"Did not find language source for given address:\" + address);\r\n        }\r\n    }\r\n}\r\nclass PutAdapter {\r\n    #agent;\r\n    #storagePath;\r\n    constructor(context){\r\n        this.#agent = context.agent;\r\n        if (\"storagePath\" in context.customSettings) {\r\n            this.#storagePath = context.customSettings[\"storagePath\"];\r\n        } else {\r\n            this.#storagePath = \"./tst-tmp/languages\";\r\n        }\r\n    }\r\n    async createPublic(language) {\r\n        const hash = UTILS.hash(language.bundle.toString());\r\n        if (hash != language.meta.address) throw new Error(`Language Persistence: Can't store language. Address stated in meta differs from actual file\\nWanted: ${language.meta.address}\\nGot: ${hash}`);\r\n        const agent = this.#agent;\r\n        const expression = agent.createSignedExpression(language.meta);\r\n        const metaPath = join3(this.#storagePath, `meta-${hash}.json`);\r\n        const bundlePath = join3(this.#storagePath, `bundle-${hash}.js`);\r\n        console.log(\"Writing meta & bundle path: \", metaPath, bundlePath);\r\n        Deno.writeTextFileSync(metaPath, JSON.stringify(expression));\r\n        Deno.writeTextFileSync(bundlePath, language.bundle.toString());\r\n        return hash;\r\n    }\r\n}\r\nclass Adapter {\r\n    putAdapter;\r\n    #storagePath;\r\n    constructor(context){\r\n        this.putAdapter = new PutAdapter(context);\r\n        if (\"storagePath\" in context.customSettings) {\r\n            this.#storagePath = context.customSettings[\"storagePath\"];\r\n        } else {\r\n            this.#storagePath = \"./tst-tmp/languages\";\r\n        }\r\n    }\r\n    async get(address) {\r\n        const metaPath = join3(this.#storagePath, `meta-${address}.json`);\r\n        try {\r\n            // await Deno.stat(metaPath);\r\n            const metaFileText = Deno.readTextFileSync(metaPath);\r\n            const metaFile = JSON.parse(metaFileText);\r\n            return metaFile;\r\n        } catch (e)  {\r\n            console.log(\"Did not find meta file for given address:\" + address, e);\r\n            return null;\r\n        }\r\n    }\r\n}\r\nconst name = \"languages\";\r\nfunction interactions(expression) {\r\n    return [];\r\n}\r\nasync function create(context) {\r\n    const expressionAdapter = new Adapter(context);\r\n    const languageAdapter = new LangAdapter(context);\r\n    return {\r\n        name,\r\n        expressionAdapter,\r\n        languageAdapter,\r\n        interactions\r\n    };\r\n}\r\nexport { name as name };\r\nexport { create as default };\r\n"}